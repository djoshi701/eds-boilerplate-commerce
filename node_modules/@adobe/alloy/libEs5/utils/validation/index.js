"use strict";

exports.string = exports.objectOf = exports.number = exports.mapOfValues = exports.literal = exports.enumOf = exports.callback = exports.boolean = exports.arrayOf = exports.anything = exports.anyOf = void 0;
var _utils = require("./utils.js");
var _booleanValidator = require("./booleanValidator.js");
var _callbackValidator = require("./callbackValidator.js");
var _createArrayOfValidator = require("./createArrayOfValidator.js");
var _createDefaultValidator = require("./createDefaultValidator.js");
var _createDeprecatedValidator = require("./createDeprecatedValidator.js");
var _createLiteralValidator = require("./createLiteralValidator.js");
var _createMapOfValuesValidator = require("./createMapOfValuesValidator.js");
var _createMinimumValidator = require("./createMinimumValidator.js");
var _createMaximumValidator = require("./createMaximumValidator.js");
var _createNoUnknownFieldsValidator = require("./createNoUnknownFieldsValidator.js");
var _createNonEmptyValidator = require("./createNonEmptyValidator.js");
var _createObjectOfValidator = require("./createObjectOfValidator.js");
var _createAnyOfValidator = require("./createAnyOfValidator.js");
var _createUniqueValidator = require("./createUniqueValidator.js");
var _createUniqueItemsValidator = require("./createUniqueItemsValidator.js");
var _domainValidator = require("./domainValidator.js");
var _integerValidator = require("./integerValidator.js");
var _numberValidator = require("./numberValidator.js");
var _regexpValidator = require("./regexpValidator.js");
var _requiredValidator = require("./requiredValidator.js");
var _stringValidator = require("./stringValidator.js");
var _matchesRegexpValidator = require("./matchesRegexpValidator.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/ /**
 * Validators are functions of two parameters (value and path) that return the
 * computed value if the input is valid, or throw an exception if the input is
 * invalid. In most cases the returned value is the same as the input value;
 * however, reference createDefaultValidator.js to see an example where the
 * computed value is different from the input. Additionally, if we ever wanted
 * to coerce types (i.e. parse string values into integers) as part of the
 * validation process we could use the computed value to accomplish that.
 *
 * The path parameter is used to generate informative error messages. It is
 * created by the objectOf, and arrayOf validators so that any error message can
 * describe which key within the object or array is invalid.
 *
 * The validators also have methods to chain additional validation logic. For
 * example, when you call `string()` to start a validator chain, it returns a
 * validator function but it also has methods like `required` and `nonEmpty`.
 * Here you can see that these methods are actually calling `chain`.
 * Specifically in this function, the leftValidator is called first and then the
 * return value of that is sent to the rightValidator. For example, when calling
 * `string().nonEmpty().required()` the following chain is built up:
 * ```
 *              *
 *            /   \
 *          *     required
 *        /   \
 *      *     nonEmpty
 *    /   \
 * base   string
 * ```
 * Where every * is a call to chain where the two are combined. The individual
 * validators are called from left to right in the above tree. The base
 * validator is simply the identity function `value => value`, representing an
 * optional value.
 *
 * After combining the validators, the new validator function is then augmented
 * with the methods from the leftValidator and from the additionalMethods
 * parameter. For example, when the string() function is called it chains to the
 * base validator, but also adds additional methods like (`regexp`, `domain`,
 * `nonEmpty`, and `unique`). When `nonEmpty` is called, which calls chain
 * again, the additional methods are carried forward because they are already
 * defined on the leftValidator.
 *
 * The base validator also contains the two methods `required` and `default`, so
 * these can be used anywhere after any of the exposed validator functions are
 * called.
 *
 * For most validators, we want the validation to be optional (i.e. allow null
 * or undefined values). To accomplish this, the validator needs to have a check
 * at the begining of the function, short circuiting the validation logic and
 * returning value if value is null or undefined. `default` and `required` do
 * not want this null check though. Indeed, `default` should return the default
 * value if value is null, and `required` should throw an error if value is
 * null.
 *
 * So to keep from having to have a null check in front of most validators,
 * nullSafeChain allows you to chain a validator in a null-safe way.
 */
// The base validator does no validation and just returns the value unchanged
var base = function base(value) {
  return value;
};

// The 'default', 'required', and 'deprecated' methods are available after any
// data-type method. Don't use the nullSafeChain on 'default' or 'required'
// because they need to handle the null or undefined case
base.default = function _default(defaultValue) {
  return (0, _utils.chain)(this, (0, _createDefaultValidator.default)(defaultValue));
};
base.required = function required() {
  return (0, _utils.chain)(this, _requiredValidator.default);
};

// helper validators
var domain = function domain() {
  return (0, _utils.nullSafeChain)(this, _domainValidator.default);
};
var minimumInteger = function minimumInteger(minValue) {
  return (0, _utils.nullSafeChain)(this, (0, _createMinimumValidator.default)("an integer", minValue));
};
var minimumNumber = function minimumNumber(minValue) {
  return (0, _utils.nullSafeChain)(this, (0, _createMinimumValidator.default)("a number", minValue));
};
var maximumNumber = function maximumNumber(maxValue) {
  return (0, _utils.nullSafeChain)(this, (0, _createMaximumValidator.default)("a number", maxValue));
};
var integer = function integer() {
  return (0, _utils.nullSafeChain)(this, _integerValidator.default, {
    minimum: minimumInteger
  });
};
var nonEmptyString = function nonEmptyString() {
  return (0, _utils.nullSafeChain)(this, (0, _createNonEmptyValidator.default)("a non-empty string"));
};
var nonEmptyArray = function nonEmptyArray() {
  return (0, _utils.nullSafeChain)(this, (0, _createNonEmptyValidator.default)("a non-empty array"));
};
var nonEmptyObject = function nonEmptyObject() {
  return (0, _utils.nullSafeChain)(this, (0, _createNonEmptyValidator.default)("a non-empty object"));
};
var regexp = function regexp() {
  return (0, _utils.nullSafeChain)(this, _regexpValidator.default);
};
var matches = function matches(regexpPattern) {
  return (0, _utils.nullSafeChain)(this, (0, _matchesRegexpValidator.default)(regexpPattern));
};
var unique = function createUnique() {
  return (0, _utils.nullSafeChain)(this, (0, _createUniqueValidator.default)());
};
var uniqueItems = function createUniqueItems() {
  return (0, _utils.nullSafeChain)(this, (0, _createUniqueItemsValidator.default)());
};

// top-level validators.  These are the first functions that are called to create a validator.
var anyOf = function anyOf(validators, message) {
  // use chain here because we don't want to accept null or undefined unless at least
  // one of the validators accept null or undefined.
  return (0, _utils.chain)(this, (0, _createAnyOfValidator.default)(validators, message));
};
var anything = function anything() {
  return this;
};
var arrayOf = function arrayOf(elementValidator) {
  return (0, _utils.nullSafeChain)(this, (0, _createArrayOfValidator.default)(elementValidator), {
    nonEmpty: nonEmptyArray,
    uniqueItems: uniqueItems
  });
};
var boolean = function boolean() {
  return (0, _utils.nullSafeChain)(this, _booleanValidator.default);
};
var callback = function callback() {
  return (0, _utils.nullSafeChain)(this, _callbackValidator.default);
};
var literal = function literal(literalValue) {
  return (0, _utils.nullSafeChain)(this, (0, _createLiteralValidator.default)(literalValue));
};
var number = function number() {
  return (0, _utils.nullSafeChain)(this, _numberValidator.default, {
    minimum: minimumNumber,
    maximum: maximumNumber,
    integer: integer,
    unique: unique
  });
};
var mapOfValues = function mapOfValues(valuesValidator) {
  return (0, _utils.nullSafeChain)(this, (0, _createMapOfValuesValidator.default)(valuesValidator), {
    nonEmpty: nonEmptyObject
  });
};
var createObjectOfAdditionalProperties = function createObjectOfAdditionalProperties(schema) {
  return {
    noUnknownFields: function noUnknownFields() {
      return (0, _utils.nullSafeChain)(this, (0, _createNoUnknownFieldsValidator.default)(schema));
    },
    nonEmpty: nonEmptyObject,
    concat: function concat(otherObjectOfValidator) {
      // combine the schema so that noUnknownFields, and concat have the combined schema
      var newSchema = _objectSpread(_objectSpread({}, schema), otherObjectOfValidator.schema);
      return (0, _utils.nullSafeChain)(this, otherObjectOfValidator, createObjectOfAdditionalProperties(newSchema));
    },
    deprecated: function deprecated(oldField, oldSchema, newField) {
      // Run the deprecated validator first so that the deprecated field is removed
      // before the objectOf validator runs.
      return (0, _utils.reverseNullSafeChainJoinErrors)(this, (0, _createDeprecatedValidator.default)(oldField, oldSchema, newField));
    },
    schema: schema
  };
};
var objectOf = function objectOf(schema) {
  return (0, _utils.nullSafeChain)(this, (0, _createObjectOfValidator.default)(schema), createObjectOfAdditionalProperties(schema));
};
var string = function string() {
  return (0, _utils.nullSafeChain)(this, _stringValidator.default, {
    regexp: regexp,
    domain: domain,
    nonEmpty: nonEmptyString,
    unique: unique,
    matches: matches
  });
};
var boundAnyOf = exports.anyOf = anyOf.bind(base);
var boundAnything = exports.anything = anything.bind(base);
var boundArrayOf = exports.arrayOf = arrayOf.bind(base);
var boundBoolean = exports.boolean = boolean.bind(base);
var boundCallback = exports.callback = callback.bind(base);
var boundLiteral = exports.literal = literal.bind(base);
var boundNumber = exports.number = number.bind(base);
var boundMapOfValues = exports.mapOfValues = mapOfValues.bind(base);
var boundObjectOf = exports.objectOf = objectOf.bind(base);
var boundString = exports.string = string.bind(base);

// compound validators
var boundEnumOf = exports.enumOf = function boundEnumOf() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }
  return boundAnyOf(values.map(boundLiteral), "one of these values: [" + JSON.stringify(values) + "]");
};